package github

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	gh "github.com/google/go-github/v69/github"
	"golang.org/x/oauth2"

	"github.com/had-nu/lazy.go/pkg/config"
)

// RepoOptions holds settings for repository creation.
type RepoOptions struct {
	Name        string
	Description string
	Private     bool
	Topics      []string
	PushOnInit  bool
	ProjectDir  string
}

// OptionsFromConfig builds RepoOptions from a ProjectConfig.
func OptionsFromConfig(cfg *config.ProjectConfig, projectDir string) RepoOptions {
	return RepoOptions{
		Name:        cfg.Name,
		Description: cfg.Description,
		Private:     cfg.Visibility == config.VisibilityPrivate,
		Topics:      cfg.GitHub.Topics,
		PushOnInit:  cfg.GitHub.PushOnInit,
		ProjectDir:  projectDir,
	}
}

// CreateRepository creates a GitHub repository and optionally pushes the project.
// It prefers the GitHub API when a token is available, falls back to gh CLI.
func CreateRepository(ctx context.Context, opts RepoOptions) error {
	if err := ValidateAuth(); err != nil {
		return err
	}

	token := TokenFromEnv()

	if token != "" {
		if err := createViaAPI(ctx, opts, token); err != nil {
			return fmt.Errorf("GitHub API: %w", err)
		}
	} else {
		if err := createViaCLI(opts); err != nil {
			return fmt.Errorf("gh CLI: %w", err)
		}
	}

	if opts.PushOnInit {
		if err := initAndPush(opts); err != nil {
			return fmt.Errorf("git push: %w", err)
		}
	}

	return nil
}

func createViaAPI(ctx context.Context, opts RepoOptions, token string) error {
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	tc := oauth2.NewClient(ctx, ts)
	client := gh.NewClient(tc)

	repo := &gh.Repository{
		Name:        gh.Ptr(opts.Name),
		Description: gh.Ptr(opts.Description),
		Private:     gh.Ptr(opts.Private),
		AutoInit:    gh.Ptr(false),
	}

	created, _, err := client.Repositories.Create(ctx, "", repo)
	if err != nil {
		return fmt.Errorf("creating repository: %w", err)
	}

	if len(opts.Topics) > 0 {
		if _, _, err := client.Repositories.ReplaceAllTopics(ctx, *created.Owner.Login, opts.Name, opts.Topics); err != nil {
			// Non-fatal: topics are cosmetic.
			fmt.Fprintf(os.Stderr, "warn: could not set topics: %v\n", err)
		}
	}

	return nil
}

func createViaCLI(opts RepoOptions) error {
	// Use gh CLI with explicit, sanitized arguments (no shell expansion).
	visibility := "--public"
	if opts.Private {
		visibility = "--private"
	}

	args := []string{
		"repo", "create",
		sanitizeName(opts.Name),
		visibility,
		"--description", opts.Description,
		"--source", opts.ProjectDir,
		"--remote", "origin",
	}

	cmd := exec.Command("gh", args...) //nolint:gosec
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func initAndPush(opts RepoOptions) error {
	dir := opts.ProjectDir

	run := func(name string, args ...string) error {
		cmd := exec.Command(name, args...) //nolint:gosec
		cmd.Dir = dir
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		return cmd.Run()
	}

	gitDir := filepath.Join(dir, ".git")
	if _, err := os.Stat(gitDir); os.IsNotExist(err) {
		if err := run("git", "init", "-b", "main"); err != nil {
			return fmt.Errorf("git init: %w", err)
		}
	}

	if err := run("git", "add", "."); err != nil {
		return fmt.Errorf("git add: %w", err)
	}

	if err := run("git", "commit", "-m", "chore: initial commit (generated by lazy.go)"); err != nil {
		return fmt.Errorf("git commit: %w", err)
	}

	if err := run("git", "push", "-u", "origin", "main"); err != nil {
		return fmt.Errorf("git push: %w", err)
	}

	return nil
}

// sanitizeName removes characters that are unsafe for repository names.
func sanitizeName(name string) string {
	name = strings.TrimSpace(name)
	var sb strings.Builder
	for _, r := range name {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' || r == '.' {
			sb.WriteRune(r)
		}
	}
	return sb.String()
}
